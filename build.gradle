plugins {
    id 'groovy'
    id 'java-library'
    id 'maven-publish'
    id 'com.github.ben-manes.versions' version '0.42.0'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.cadixdev.licenser' version '0.6.1'
}

import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import shadow.org.apache.tools.zip.ZipEntry
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.codehaus.plexus.util.IOUtil

class UpdatedGroovyExtensionModuleTransformer implements Transformer {

    private static final GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH =
            "META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule" // The only change...

    private static final MODULE_NAME_KEY = 'moduleName'
    private static final MODULE_VERSION_KEY = 'moduleVersion'
    private static final EXTENSION_CLASSES_KEY = 'extensionClasses'
    private static final STATIC_EXTENSION_CLASSES_KEY = 'staticExtensionClasses'

    private static final MERGED_MODULE_NAME = 'MergedByShadowJar'
    private static final MERGED_MODULE_VERSION = '1.0.0'

    private final Properties module = new Properties()

    @Override
    boolean canTransformResource(FileTreeElement element) {
        return element.relativePath.pathString == GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH
    }

    @Override
    void transform(TransformerContext context) {
        def props = new Properties()
        props.load(context.is)
        props.each { String key, String value ->
            switch (key) {
                case MODULE_NAME_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_NAME)
                    }
                    break
                case MODULE_VERSION_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_VERSION)
                    }
                    break
                case [EXTENSION_CLASSES_KEY, STATIC_EXTENSION_CLASSES_KEY]:
                    handle(key, value) { String existingValue ->
                        def newValue = "${existingValue},${value}"
                        module.setProperty(key, newValue)
                    }
                    break
            }
        }
    }

    private handle(String key, String value, Closure mergeValue) {
        def existingValue = module.getProperty(key)
        if (existingValue) {
            mergeValue(existingValue)
        } else {
            module.setProperty(key, value)
        }
    }

    @Override
    boolean hasTransformedResource() {
        return module.size() > 0
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        ZipEntry entry = new ZipEntry(GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH)
        entry.time = TransformerContext.getEntryTimestamp(preserveFileTimestamps, entry.time)
        os.putNextEntry(entry)
        IOUtil.copy(toInputStream(module), os)
        os.closeEntry()
    }

    private static InputStream toInputStream(Properties props) {
        def baos = new ByteArrayOutputStream()
        props.store(baos, null)
        return new ByteArrayInputStream(baos.toByteArray())
    }
}

static String getGitCommit() {
    final proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue() ? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

final Map<String, String> groovy(final String name) {
    return [
            group: 'org.apache.groovy',
            name: name == 'stdlib' ? 'groovy' : "groovy-${name}",
            version: project.ext.groovyVersion
    ]
}

version = '1.1.0'
group = 'net.thesilkminer.mc.austin'
archivesBaseName = 'austin-powerful-language-provider-keeping-it-groovy-baby'

java {
    toolchain.languageVersion = JavaLanguageVersion.of(17)
    withSourcesJar()
}

license {
    header = project.file('LICENSE-header.txt')
    ext['year'] = Calendar.instance.get(Calendar.YEAR)
}

minecraft {
    mappings channel: 'official', version: '1.18.2'

    runs {
        configureEach {
            workingDirectory project.file('run')
            property 'forge.logging.console.level', 'debug'

            lazyToken('minecraft_classpath') {
                configurations.shade.copyRecursive().resolve().collect { it.absolutePath }.join(File.pathSeparator)
            }

            mods {
                austinspowerfullanguageproviderkeepingitgroovybaby {
                    source sourceSets.main
                }
                mojotest {
                    source sourceSets.test
                }
            }
        }

        client { args '--username', 'Dev##' }
        server { args '--nogui' }
    }
}

configurations {
    shade {}
    yeet {}
    api.extendsFrom(shade)
}

repositories {
    maven {
        name = 'Modding Inquisition Releases'
        url = 'https://maven.moddinginquisition.org/releases'
    }
    mavenCentral()
}

dependencies {
    minecraft group: 'net.minecraftforge', name: 'forge', version: '1.18.2-40.2.0'

    final Map<String, List<String>> groovyLibs = [
            shade: [
                    'stdlib', 'astbuilder', 'cli-picocli',
                    'contracts', 'datetime', 'dateutil', 'ginq',
                    'json', 'jsr223', 'macro', 'macro-library',
                    'nio', 'templates', 'test', 'test-junit5',
                    'toml', 'typecheckers', 'xml', 'yaml'
            ],
            yeet: [
                    'ant', 'backports-compat-23', 'binary', 'bom', 'bsf',
                    'cli-commons', 'console', 'docgenerator', 'groovydoc',
                    'groovysh', 'jaxb', 'jmx', 'servlet',
                    'sql', 'swing', 'testing'
            ]
    ]
    groovyLibs.shade.each { final String dep -> shade groovy(dep) }
    groovyLibs.yeet.each { final String dep -> yeet groovy(dep) }

    compileOnly 'com.matyrobbrt.enhancedgroovy:dsl:0.2.0'
}

tasks.named('jar', Jar).configure {
    archiveClassifier.set('')
    manifest {
        attributes([
            'Specification-Title': 'austins-powerful-language-provider-keeping-it-groovy-baby',
            'Specification-Vendor': 'TheSilkMiner',
            'Specification-Version': '1',
            'Implementation-Title': project.name,
            'Implementation-Version': archiveVersion.get(),
            'Implementation-Vendor' : 'TheSilkMiner',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'GitCommit': getGitCommit(),
            'FMLModType': 'LANGPROVIDER',
            'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb'
        ])
    }

    finalizedBy 'reobfJar'
}

tasks.named('shadowJar', ShadowJar).configure {
    archiveClassifier.set('all')
    configurations = [project.configurations.shade]

    exclude '**/module-info.class',
            'LICENSE.txt', 'LICENSE-junit.txt',
            'META-INF/LICENSE.txt', 'META-INF/LICENSE.md', 'META-INF/LICENSE-header.txt',
            '**/*.psd'

    transform(UpdatedGroovyExtensionModuleTransformer)
    mergeServiceFiles()

    finalizedBy 'reobfShadowJar'
    dependsOn 'reobfJar'
}

tasks.register('testJar', Jar) {
    archiveClassifier.set('test')
    from sourceSets.test.output
    finalizedBy 'reobfTestJar'
    dependsOn 'shadowJar'
}

tasks.named('build').configure {
    dependsOn 'testJar'
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
            artifacts = [jar, sourcesJar, shadowJar]
            artifactId = 'aplp-1.18.2'
            pom.withXml { node ->
                node.asNode().dependencies
                        .'*'
                        .findAll { it.version.text().contains('mapped') }
                        .each { it.parent().remove(it) }
            }
        }
    }
    repositories {
        maven {
            name = 'ModdingInquisitionMavenRepo'
            url = 'https://maven.moddinginquisition.org/releases'
            credentials {
                username = findProperty('inquisitionMavenUser') ?: ''
                password = findProperty('inquisitionMavenPassword') ?: ''
            }
        }
    }
}

reobf {
    shadowJar {}
    testJar {}
}

tasks.withType(GroovyCompile).configureEach {
    groovyOptions.encoding = 'UTF-8'
    groovyOptions.optimizationOptions.indy = true
    options.incremental = true
}

tasks.withType(GenerateModuleMetadata).configureEach {
    enabled = false
}

// APLP is written in pure Groovy, so delete the empty java folder in each of the sourceSets
sourceSets.each { sourceSet ->
    final javaDir = file("src/${sourceSet.name}/java/")
    javaDir.deleteDir()
}
